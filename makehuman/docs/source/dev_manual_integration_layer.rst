.. _integration_layer:

.. highlight:: python
   :linenothreshold: 5

Integration Layer, program entry and exit
============================================


Specific low-level and high level functionality and events are exposed through a C/Python integration layer enabling high-level GUI operations to be delivered using interpreted Python code. The integration layer passes calls from the C code to the main Python module to handle events detected by the SDL module. These calls are made by functions in core.c which use the PyRun_SimpleString function to invoke Python functions. The integration layer also incorporates a series of C functions exposed through a Python class (named 'mh.') that is dynamically generated by main.c when the application starts. This class is created using the Py_InitModule function which registers a series of C functions as Python methods on the 'mh.' class. This provides a mechanism by which the various Python modules (called in response to an event), can interact with the generic functions and the global data structure in the C core.

Program entry
--------------

When the application starts, it starts by initializing all global variables. Then it prepares to call the main python entry, first setting the program name, initializing python, passing the program arguments and creating the makehuman python module.

When all that is done, main.py is called. This is done using::

    PyRun_SimpleString("execfile(\"main.py\")");

The reason this method is preferred instead of PyRun_SimpleFile is that the latter might crash on windows because of incompatible structures. Python 2.6 is compiled with Visual Studio 9, which filestructures are different from MinGW or Visual Studio 8.


Python entry
-------------

The main python script starts by loading the necessary modules, and creating the scene object. This object contains a list of the objects in the scene, as well as a dictionary mapping selection color to object. After the scene is created, the base mesh as well as the GUI meshes are loaded into the scene. At that point in time, all 3D geometry has been imported into the python runtime, but not yet into OpenGL.

Thus the next logical step is to copy the geometry to the C runtime which creates the necessary OpenGL vertex buffers (and textures?). Finally the event handlers are connected and the GUI is switched to modeling mode. At that point, the Python script calls startWindow which creates the window in the C runtime and starts the event loop.
SDL event loop.

In most modern GUI's, an event loop takes control once everything is initialized. Our loop blocks on SDL_WaitEvent which waits for user input and/or timers. When an event occurs, it is translated and passed to the Python runtime. After handling the event, Python returns control to the event loop.

Redrawing is done by placing an expose event into the event queue. We don't just call draw directly because, if running on a slow system, the event queue would fill up and, after the user has finishes generating input events, a history of those events would be 'played' out. This is solved in two steps. Instead of calling draw directly, an expose event is posted in the event queue. This makes the drawing asynchronous just like the input events. This would still give the same problem, as many events would be posted, which can't be handled in time. To avoid this we mark that an expose event was put into the queue, and we don't place a new one in the queue until it is taken out of the queue and processed. This makes sense as we don't need to tell the system twice or more times to redraw, once an event is pending a redraw will occur eventually.

This way the system stays as responsive as possible, while drawing at the smoothest frame rate possible. 

::

    // The event loop
    while not finished
        wait for event
        check event type
            input: pass to python
            expose: draw and clear pending flag
            custom: call python timer
            quit: finished

    // The redraw method
    if pending flag
        return
    set pending flag
    queue expose event



A similar strategy is used for timers. instead of calling the python callback directly from the SDL timer callback, we push a custom event into the queue and only if there isn't already one in the queue. This is done because the SDL timer callback is called from another thread, which might crash the Python runtime. Once the event loop finishes, the OpenGL textures are freed. And the event loop function returns. This brings control back to the Python runtime which finishes it's main script and returns as well.

Program Exit
----------------

Python is finalized and all object memory is freed.

The handler uses the dynamically created mh Python module to call mh_shutDown in main.c which in turn calls mhShutDown in glmodule.c. This issues a system exit(0) to end the application event loop. The exit performs a cleanup and control is passed back through the main function in the main.c file which issues a 'goodbye' message and exits.
